
객체와 원시 타입의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사된다는 것

원시값(문자열, 숫자, 불린 값)은 ‘값 그대로’ 저장·할당되고 복사됨

```jsx
let message = "Hello!";
let phrase = message;
```

**변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 '메모리 주소’인 객체에 대한 '참조 값’이 저장됨.**

```jsx
let user = { name: "John" };

let admin = user; // 참조값을 복사함

let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨

alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인함
```

객체는 메모리 내 어딘가 저장되고, 변수 user에는 참조할 수 있는 값이 저장됨.

```jsx
let a = {};
let b = a; // 참조에 의한 복사 <- 똑같지만 독립적이지 않음.

alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
alert( a === b ); // true

let a = {};
let b = {}; // 독립된 두 객체

alert( a == b ); // false
```

### 가비지 컬렉션

자바스크립트는 *도달 가능성(reachability)* 이라는 개념을 사용해 메모리 관리를 수행합니다.

도달 가능한 값은 메모리에서 삭제되지 않습니다.

아래 값은 명백한 이유없이 삭제되지 않음.

- 현재 함수의 지역 변수와 매개변수
- 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
- 전역 변수
- 기타 등등

이런 값은 *루트(root)* 라고 부릅니다.

'가비지 컬렉션’은 대개 다음 단계를 거쳐 수행됩니다.

- 가비지 컬렉터는 루트(root) 정보를 수집하고 이를 ‘mark(기억)’ 합니다.
- 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 ‘mark’ 합니다.
- mark 된 모든 객체에 방문하고 *그 객체들이* 참조하는 객체도 mark 합니다. 한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.
- 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.
- mark 되지 않은 모든 객체를 메모리에서 삭제합니다.

### 메서드와 this

객체 프로퍼티에 할당된 함수를 *메서드(method)* 라고 부릅니다.

```jsx
user.sayHi = function() {
  alert("안녕하세요!");
};

user = {
name : 'aaa', 
  sayHi() { // "sayHi: function()"과 동일합니다.
    alert(`Hello ${this.name}`); // this 키워드로 내부 프로퍼티에 접근 가능
  }
};
```

this 값은 런타임에서 결정된다. 

동일한 함수라도 다른 객체에서 호출했다면 this가 참조하는 값이 달라짐.

```jsx
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// 별개의 객체에서 동일한 함수를 사용함
user.f = sayHi;
admin.f = sayHi;

// 'this'는 '점(.) 앞의' 객체를 참조하기 때문에
// this 값이 달라짐
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (점과 대괄호는 동일하게 동작함)
```

화살표 함수는 일반 함수와 달리 고유한 this를 가지지 않는다.

외부 컨텍스트에 있는 this를 이용하고 싶다면 화살표 함수가 유용

```jsx
let user = {
  firstName: "보라",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // 보라
```

### 심볼

자바스크립트는 객체 프로퍼티 키로 오직 문자형과 심볼형만을 허용합니다. 숫자형, 불린형 모두 불가능하고 오직 문자형과 심볼형만 가능하죠.

유일한 식별자를 만드는 데 사용됨.

심볼의 주요 유스 케이스는 다음과 같습니다.

1. 객체의 ‘숨김’ 프로퍼티 – 외부 스크립트나 라이브러리에 ‘속한’ 객체에 새로운 프로퍼티를 추가해 주고 싶다면 심볼을 만들고, 이를 프로퍼티 키로 사용하면 됩니다. 키가 심볼인 경우엔 `for..in`의 대상이 되지 않아서 의도치 않게 프로퍼티가 수정되는 것을 예방할 수 있습니다. 외부 스크립트나 라이브러리는 심볼 정보를 갖고 있지 않아서 프로퍼티에 직접 접근하는 것도 불가능합니다. 심볼형 키를 사용하면 프로퍼티가 우연히라도 사용되거나 덮어씌워 지는 걸 예방할 수 있습니다.
    
    이런 특징을 이용하면 원하는 것을 객체 안에 ‘은밀하게’ 숨길 수 있습니다. 외부 스크립트에선 우리가 숨긴 것을 절대 볼 수 없습니다.
    
2. 자바스크립트 내부에서 사용되는 시스템 심볼은 `Symbol.*`로 접근할 수 있습니다. 시스템 심볼을 이용하면 내장 메서드 등의 기본 동작을 입맛대로 변경할 수 있습니다.

```jsx
// id는 새로운 심볼이 됩니다.
let id = Symbol();

// 심볼 id에는 "id"라는 설명이 붙습니다.
let id = Symbol("id");

//유일성이 보장되는 자료형이다.
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false

let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
//심볼은 문자형으로 자동 형 변환되지 않습니다.
```

키가 심볼인 프로퍼티는 `for..in` 반복문에서 배제됩니다.

```jsx
let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // "id": 123은 안됨
};

let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name과 age만 출력되고, 심볼은 출력되지 않습니다.

// 심볼로 직접 접근하면 잘 작동합니다.
alert( "직접 접근한 값: " + user[id] );
```

### new 연산자와 생성함수

생성자 함수(constructor function)와 일반 함수에 기술적인 차이는 없습니다. 다만 생성자 함수는 아래 두 관례를 따릅니다.

1. 함수 이름의 첫 글자는 대문자로 시작합니다.
2. 반드시 `'new'` 연산자를 붙여 실행합니다.

```jsx
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("보라");

alert(user.name); // 보라
alert(user.isAdmin); // false

//new User(...)를 써서 함수를 실행하면 아래와 같은 알고리즘이 동작합니다.

```

생성자 함수엔 보통 return 문이 없음. 반환해야 할 것들은 모두 this에 저장되고, this 는 자동으로 반환 되기 때문에 반환문을 명시적으로 써 줄 필요가 없음.

그런데 만약 `return` 문이 있다면 어떤 일이 벌어질까요? 아래와 같은 간단한 규칙이 적용됩니다.

- 객체를 `return` 한다면 `this` 대신 객체가 반환됩니다.
- 원시형을 `return` 한다면 `return`문이 무시됩니다.

```jsx
function BigUser() {

  this.name = "원숭이";

  return { name: "고릴라" };  // <-- this가 아닌 새로운 객체를 반환함
}

alert( new BigUser().name );  // 고릴라
```

## 나눠볼 질문

Q : 생성자 함수 안의 this의 값은 어디를 가르키는지?

A : 생성된 인스턴스를 가리킨다.

Q : 생성자 함수란?

A : new 생성자 함수로 호출하고, this가 인스턴스를 가리키는 함수.

Q : 기본형과 참조형의 가장 큰 차이가 무엇일까요?

A : 기본형은 immutable 합니다. 참조형은 mutable 합니다.기본형의 불변은 새로운 값을 다시 할당할 수는 있으나, 이미 생성된 원시값을 변경할 수는 없음을 의미합니다.참조형의 가변은 내부 프로퍼티 변경 시 성립합니다.참조형 데이터는 여러 개의 프로퍼티(변수)를 모은 그룹이기에 내부의 프로퍼티를 변경할 수 있는 가변값으로 여길 수 있습니다.

Q : 상수와 불변의 차이는 무엇일까요?

A : 상수는 변수에 데이터를 재할당할 수 없는 변수이며불변은 메모리에 있는 데이터를 변경할 수 없는 것을 의미합니다.

Q : 불변성이 왜 필요할까요?

A : 원본 데이터는 변하지 않아야 하는 경우가 있기 때문입니다.원본 데이터가 다양한 원인으로 변경되면 변경 추적이 어려워질 수 있습니다. 객체지향 프로그래밍의 경우 setter를 사용하여 변경을 추적하는 이유입니다

Q : 얕은 복사와 깊은 복사의 차이는 무엇일까요?

A : **얕은 복사**는 원본의 프로퍼티의 타입이 참조형일 경우, 주소값만 복사하여 원본과 동일한 참조형 데이터의 주소를 가리키게 됩니다.(사본과 원본의 변화를 공유하여 사이드이펙트가 발생할 수 있습니다.) **깊은 복사**의 경우 해당 참조형 데이터와 동일한 객체를 새로 생성하여 복사된 객체의 프로퍼티에 해당 참조형 데이터의 주소를 저장합니다. 따라서 원본과 독립적입니다.

Q :  javascript의 call by value에 대한 설명

**값에 의한 호출 (Call by Value):**  함수의 평가 시에 인수 값을 새 메모리 영역에 복사해 해당 함수의 로컬 변수에 바인딩 합니다.

함수로 전달되는 것은 값 자체이며, 이 값은 함수 파라미터에 복사됩니다. 이는 호출된 함수에서 파라미터 값을 변경하더라도 호출한 쪽에서는 영향을 받지 않습니다.

```jsx
function increment(x) {
    x++;
}

let num = 5;
increment(num);
console.log(num); // 출력값: 5 (변경되지 않음)
```

**참조에 의한 호출 (Call by Reference):** 함수로 전달되는 것은 값이 아니라 해당 값이 저장된 메모리 주소(참조)이며, 함수 안에서 이를 참조하여 변경하면 호출한 곳에서도 영향을 받습니다. 자바스크립트에서는 이 개념이 적용되지 않습니다.

```jsx
function changeArray(arr) {
    arr.push(4);
}

let myArray = [1, 2, 3];
changeArray(myArray);
console.log(myArray); // 출력값: [1, 2, 3, 4] (변경됨)
```

Q : 일급 객체란?

자바스크립트에서는 함수를 포함한 모든 것이 일급 객체이다.

일급 객체의 특징

- **변수에 할당 가능 (First-Class Citizens):** 함수는 변수에 할당할 수 있습니다. 이는 함수를 다른 변수에 저장하거나, 함수를 다른 함수에 전달할 수 있다는 것을 의미합니다.
- **함수의 반환 값으로 사용 가능:** 함수는 다른 함수의 반환 값으로 사용될 수 있습니다.
- **함수를 인자로 받을 수 있음:** 함수는 다른 함수의 인자로 전달될 수 있습니다.
- **객체의 프로퍼티로 사용 가능:** 함수는 객체의 속성으로 사용될 수 있습니다.

Q.  : **화살표 수(arrow function)에서 `this`는 어떻게 동작하는지 설명해주세요.**

A. : **설명:** 화살표 함수는 자신만의 **`this`**를 생성하지 않고, 주변 스코프의 **`this`** 값을 가져옵니다. 따라서 화살표 함수 내에서 **`this`**는 함수가 아닌 주변 스코프의 **`this`** 값을 유지합니다.

Q : 얕은 복사, 깊은 복사 차이점?

A : 얕은 복사는 원본 객체의 최상위 수준의 속성만을 복사합니다. 내부에 있는 객체나 배열은 참조로 복사되기 때문에 원본과 복사본이 같은 객체를 참조할 수 있습니다.

깊은복사 : 깊은 복사는 원본 객체 및 내부의 모든 객체와 배열을 재귀적으로 복사합니다. 따라서 원본과 복사본은 완전히 독립된 객체입니다.

Q. rest …와  [… ] spread 연산자의 차이점

A : **Spread 문법**은 주로 배열이나 객체의 요소를 펼치는 데 사용되고, 배열이나 객체 리터럴에서 사용됩니다.

**Rest 문법**은 주로 함수의 매개변수에서 사용되며, 함수에 전달된 인수 중에서 일부를 배열로 수집하는 데 사용됩니다. 함수 선언 시 사용되는 것이 일반적입니다.
